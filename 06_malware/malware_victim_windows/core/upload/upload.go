package upload

import (
	"archive/zip"
	"bufio"
	"encoding/gob"
	"fmt"
	"io/ioutil"
	"net"
	"os"
	"strings"
)

type FilesList struct {
	Files []string
}

type Data struct {
	FileName    string
	FileSize    int
	FileContent []byte
}

func Add_files_to_zip(zip_writer *zip.Writer, folder string, base_in_zip string) {
	files, err := ioutil.ReadDir(folder)
	if err != nil {
		fmt.Println(err)
	}

	for _, file := range files {
		fmt.Println("[+] ", file.Name())

		if !file.IsDir() {
			data, err := ioutil.ReadFile(file.Name())
			if err != nil {
				fmt.Println(err)
			}

			f, err := zip_writer.Create(base_in_zip + file.Name())
			if err != nil {
				fmt.Println(err)
			}

			f.Write(data)
		} else if file.IsDir() {
			newBase := folder + "/" + file.Name() + "/"

			fmt.Println("[+] Adding subdir: ", file.Name())
			fmt.Println("[+] Adding subdir: ", newBase)

			Add_files_to_zip(zip_writer, newBase, base_in_zip+file.Name()+"/")
		}
	}
}

func zipper(folder string, ouput_file string) {
	output_file, err := os.Create(ouput_file)

	if err != nil {
		fmt.Println(err)
	}

	defer output_file.Close()

	zip_writer := zip.NewWriter(output_file)

	Add_files_to_zip(zip_writer, folder, "")

	err = zip_writer.Close()

	if err != nil {
		fmt.Println(err)
	}

}

func Read_file(fileName string) ([]byte, error) {
	file, err := os.Open(fileName)
	if err != nil {
		return nil, err
	}

	defer file.Close()

	file_stats, err := file.Stat()
	if err != nil {
		return nil, err
	}

	file_size := file_stats.Size()
	fmt.Println("[+] The file contains ", file_size, " bytes")

	// make an empty list if bytes to fill
	file_bytes := make([]byte, file_size)

	buffer := bufio.NewReader(file)

	_, err = buffer.Read(file_bytes)

	return file_bytes, err
}

func Upload_files(connection net.Conn) (err error) {

	var files []string
	files_arr, err := ioutil.ReadDir(".")

	if err != nil {
		fmt.Println(err)
	}

	for _, file := range files_arr {
		mode := file.Mode()
		if !mode.IsDir() {
			files = append(files, file.Name())
		}
	}

	fl := FilesList{
		Files: files,
	}

	encoder := gob.NewEncoder(connection)
	err = encoder.Encode(fl)

	if err != nil {
		fmt.Println(err)
	}

	reader := bufio.NewReader(connection)
	file_name_raw, err := reader.ReadString('\n')

	if err != nil {
		fmt.Println(err)
	}

	file_name := strings.TrimSuffix(file_name_raw, "\n")

	content, err := Read_file(file_name)
	if err != nil {
		fmt.Println(err)
	}

	file_data := &Data{
		FileName:    file_name,
		FileSize:    len(content),
		FileContent: content,
	}

	err = encoder.Encode(file_data)
	if err != nil {
		fmt.Println(err)
	}

	return
}

func Upload_folders(connection net.Conn) (err error) {

	var folders []string
	root_dir := "."

	folders_arr, err := ioutil.ReadDir(root_dir)

	if err != nil {
		fmt.Println(err)
	}

	for _, file := range folders_arr {
		mode := file.Mode()
		if mode.IsDir() {
			folders = append(folders, file.Name())
		}
	}

	fl := FilesList{
		Files: folders,
	}

	encoder := gob.NewEncoder(connection)
	err = encoder.Encode(fl)

	if err != nil {
		fmt.Println(err)
	}

	reader := bufio.NewReader(connection)
	folder_name, err := reader.ReadString('\n')

	folder_name = strings.TrimSuffix(folder_name, "\n")

	if err != nil {
		fmt.Println(err)
	}

	zipper(folder_name, folder_name+".zip")

	content, err := Read_file(folder_name + ".zip")
	if err != nil {
		fmt.Println(err)
	}

	file_data := &Data{
		FileName:    folder_name + ".zip",
		FileSize:    len(content),
		FileContent: content,
	}

	err = encoder.Encode(file_data)
	if err != nil {
		fmt.Println(err)
	}
	return
}
